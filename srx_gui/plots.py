import collections
import functools
import itertools

from bluesky_widgets.models.utils import auto_label, call_or_eval, RunManager, run_is_live_and_not_completed
from bluesky_widgets.utils.dict_view import DictView
from bluesky_widgets.utils.event import EmitterGroup, Event
from bluesky_widgets.utils.list import EventedList

from bluesky_widgets.models.auto_plot_builders import AutoPlotter
from bluesky_widgets.models.plot_builders import Lines, Images, RasteredImages
from bluesky_widgets.models.plot_specs import Axes, Figure, Image, Line
from bluesky_widgets.models.utils import run_is_live_and_not_completed

import numpy as np

import pprint

# plan_name
# underlying_plan linescan motor type
# underlying_plan xafs trans/fluorescence/ref

monitored_line = "Br_ka1"
monitored_stream_name = f"{monitored_line}_monitor"


class RasteredImagesSRX:
    """
    Plot a rastered image from a Run.

    Parameters
    ----------

    field : string
        Field name or expression
    shape : Tuple[Integer]
        The (row, col) shape of the raster
    label_maker : Callable, optional
        Expected signature::

            f(run: BlueskyRun, y: String) -> label: String

    needs_streams : List[String], optional
        Streams referred to by field. Default is ``["primary"]``
    namespace : Dict, optional
        Inject additional tokens to be used in expressions for x and y
    axes : Axes, optional
        If None, an axes and figure are created with default labels and titles
        derived from the ``x`` and ``y`` parameters.
    clim : Tuple, optional
        The color limits
    cmap : String or Colormap, optional
        The color map to use
    extent : scalars (left, right, bottom, top), optional
        Passed through to :meth:`matplotlib.axes.Axes.imshow`
    x_positive : String, optional
        Defines the positive direction of the x axis, takes the values 'right'
        (default) or 'left'.
    y_positive : String, optional
        Defines the positive direction of the y axis, takes the values 'up'
        (default) or 'down'.

    Attributes
    ----------
    run : BlueskyRun
        The currently-viewed Run
    figure : Figure
    axes : Axes
    field : String
        Read-only access to field or expression
    needs_streams : List[String], optional
        Read-only access to streams referred to by field.
    namespace : Dict, optional
        Read-only access to user-provided namespace

    Examples
    --------
    >>> model = RasteredImages("intensity", shape=(100, 200))
    >>> from bluesky_widgets.jupyter.figures import JupyterFigure
    >>> view = JupyterFigure(model.figure)
    >>> model.add_run(run)
    """

    def __init__(
        self,
        field,
        shape,
        *,
        max_runs=1,
        label_maker=None,
        needs_streams=("primary",),
        namespace=None,
        axes=None,
        clim=None,
        cmap="viridis",
        extent=None,
        x_positive="right",
        y_positive="up",
    ):
        super().__init__()

        if label_maker is None:
            # scan_id is always generated by RunEngine but not stricter required by
            # the schema, so we fail gracefully if it is missing.

            def label_maker(run, field):
                md = run.metadata["start"]
                return f"Scan ID {md.get('scan_id', '?')}   UID {md['uid'][:8]}   {field}"

        self._label_maker = label_maker

        # Stash these and expose them as read-only properties.
        self._field = field
        self._shape = shape
        self._namespace = namespace

        self._run = None

        if axes is None:
            axes = Axes()
            figure = Figure((axes,), title="")
        else:
            figure = axes.figure
        self.axes = axes
        self.figure = figure
        # If the Axes' figure is not yet set, listen for it to be set.
        if figure is None:

            def set_figure(event):
                self.figure = event.value
                # This occurs at most once, so we can now stop listening.
                self.axes.events.figure.disconnect(set_figure)

            self.axes.events.figure.connect(set_figure)
        self._clim = clim
        self._cmap = cmap
        self._extent = extent
        self._x_positive = x_positive
        self._y_positive = y_positive

        self._run_manager = RunManager(max_runs, needs_streams)
        self._run_manager.events.run_ready.connect(self._add_image)
        self.add_run = self._run_manager.add_run
        self.discard_run = self._run_manager.discard_run

    @property
    def cmap(self):
        return self._cmap

    @cmap.setter
    def cmap(self, value):
        self._cmap = value
        for artist in self.axes.artists:
            if isinstance(artist, Image):
                artist.style.update({"cmap": value})

    @property
    def clim(self):
        return self._clim

    @clim.setter
    def clim(self, value):
        self._clim = value
        for artist in self.axes.artists:
            if isinstance(artist, Image):
                artist.style.update({"clim": value})

    @property
    def extent(self):
        return self._extent

    @extent.setter
    def extent(self, value):
        self._extent = value
        for artist in self.axes.artists:
            if isinstance(artist, Image):
                artist.style.update({"extent": value})

    @property
    def x_positive(self):
        xmin, xmax = self.axes.x_limits
        if xmin > xmax:
            self._x_positive = "left"
        else:
            self._x_positive = "right"
        return self._x_positive

    @x_positive.setter
    def x_positive(self, value):
        if value not in ["right", "left"]:
            raise ValueError('x_positive must be "right" or "left"')
        self._x_positive = value
        xmin, xmax = self.axes.x_limits
        if (xmin > xmax and self._x_positive == "right") or (xmax > xmin and self._x_positive == "left"):
            self.axes.x_limits = (xmax, xmin)
        elif (xmax >= xmin and self._x_positive == "right") or (xmin >= xmax and self._x_positive == "left"):
            self.axes.x_limits = (xmin, xmax)
            self._x_positive = value

    @property
    def y_positive(self):
        ymin, ymax = self.axes.y_limits
        if ymin > ymax:
            self._y_positive = "down"
        else:
            self._y_positive = "up"
        return self._y_positive

    @y_positive.setter
    def y_positive(self, value):
        if value not in ["up", "down"]:
            raise ValueError('y_positive must be "up" or "down"')
        self._y_positive = value
        ymin, ymax = self.axes.y_limits
        if (ymin > ymax and self._y_positive == "up") or (ymax > ymin and self._y_positive == "down"):
            self.axes.y_limits = (ymax, ymin)
        elif (ymax >= ymin and self._y_positive == "up") or (ymin >= ymax and self._y_positive == "down"):
            self.axes.y_limits = (ymin, ymax)
            self._y_positive = value

    def _add_image(self, event):
        run = event.run
        func = functools.partial(self._transform, field=self.field)
        style = {"cmap": self._cmap, "clim": self._clim, "extent": self._extent}
        image = Image.from_run(func, run, label=self.field, style=style)
        self._run_manager.track_artist(image, [run])
        md = run.metadata["start"]
        self.axes.artists.append(image)
        self.axes.title = self._label_maker(run, self.field)
        self.axes.x_label = "X"  # md["motors"][1]
        self.axes.y_label = "Y"  # md["motors"][0]
        # By default, pixels center on integer coordinates ranging from 0 to
        # columns-1 horizontally and 0 to rows-1 vertically.
        # In order to see entire pixels, we set lower limits to -0.5
        # and upper limits to columns-0.5 horizontally and rows-0.5 vertically
        # if limits aren't specifically set.
        nx, ny = md["scan"]["shape"]
        if self.axes.x_limits is None and self._x_positive == "right":
            self.axes.x_limits = (-0.5, nx - 0.5)
        elif self.axes.x_limits is None and self._x_positive == "left":
            self.axes.x_limits = (nx - 0.5, -0.5)
        if self.axes.y_limits is None and self._y_positive == "up":
            self.axes.y_limits = (-0.5, ny - 0.5)
        elif self.axes.y_limits is None and self._y_positive == "down":
            self.axes.y_limits = (ny - 0.5, -0.5)

        # TODO Try to make the axes aspect equal unless the extent is highly non-square.
        ...

    def _transform(self, run, field):
        result = call_or_eval({"data": field}, run, self.needs_streams, self.namespace)
        data = result["data"]
        data = np.array(data.load())
        import time as ttime

        print(f"New data available ... {ttime.time()} - {len(data)} points")

        md = run.metadata["start"]
        snake = md["scan"]["snake"]
        nx, ny = md["scan"]["shape"]

        n_total = nx * ny
        if len(data) > n_total:
            image_data = data[:n_total]
        else:
            image_data = np.pad(data, (0, n_total - len(data)), constant_values=np.nan)
        image_data = image_data.reshape([ny, nx])

        if snake:
            ind = np.arange(1, ny, 2)
            image_data[ind] = np.fliplr(image_data[ind])

        # # print(f"image_data={image_data}")

        vmin, vmax = float(np.min(data)), float(np.max(data))
        dv = (vmax - vmin) * 0.05
        self.clim = (vmin + dv, vmax - dv)

        # image_data = np.ones(shape=[ny, nx], dtype=np.float64)

        print(f"New data ready ... {ttime.time()}")
        # print(f"data={data}")

        return {"array": image_data}

    @property
    def namespace(self):
        return DictView(self._namespace or {})

    @property
    def field(self):
        return self._field

    @property
    def shape(self):
        return self._shape

    # Expose some properties from the internal RunManger helper class.

    @property
    def runs(self):
        return self._run_manager.runs

    @property
    def max_runs(self):
        return self._run_manager.max_runs

    @max_runs.setter
    def max_runs(self, value):
        self._run_manager.max_runs = value

    @property
    def needs_streams(self):
        return self._run_manager._needs_streams

    @property
    def pinned(self):
        return self._run_manager._pinned


class AutoSRXPlot(AutoPlotter):
    def __init__(self):
        super().__init__()
        self._models = {}
        self._figure_dict = {}

        self.plot_builders.events.removed.connect(self._on_plot_builder_removed)

    def _on_plot_builder_removed(self, event):
        plot_builder = event.item
        for key in list(self._models):
            for line in self._models[key]:
                if line == plot_builder:
                    del self._models[key]

    def add_run(self, run, **kwargs):
        print("Add run .......")  ##
        super().add_run(run, **kwargs)

    def handle_new_stream(self, run, stream_name):
        print(f"Kafka .......... stream_name={stream_name!r}")  ##
        print(f"Run metadata: {run.metadata['start']}")
        print(f"Run is live: {run_is_live_and_not_completed(run)}")
        # print(f"type(run)={type(run)}")
        # print(f"run = {pprint.pformat(list(run.documents(fill='no')))}")
        # print(f"run = {dict(run)}")
        # print(f"run = {run[monitored_stream_name].to_dask().load()}")

        # if stream_name != "primary":
        if stream_name != monitored_stream_name:
            return

        nx, ny = run._document_cache.start_doc["scan"]["shape"]

        # Find out the plan type.
        plan_name = run.metadata["start"].get("plan_name").split(" ")
        # if len(plan_name) > 1:
        #     plan = plan_name[1]

        # # Skip plan if it is not supported.
        # if plan not in ["xafs", "linescan"]:
        #     return

        # # Gather the rest of the parameters.
        # subtype = plan_name[-1]  # trans, ref, fluorescence, I0, It, Ir
        # element = run.metadata["start"].get("XDI", {}).get("Element", {}).get("symbol", False)
        # fluorescence = f"{element}1+{element}2+{element}3+{element}4" if element else None

        # # Look up what goes on the x-axis.
        # x_lookup = {"linescan": plan_name[2], "xafs": "dcm_energy"}
        # x_axis = x_lookup[plan]

        # # Look up what goes on the y-axis.
        # y_lookup = {
        #     "I0": ["I0"],
        #     "It": ["It/I0"],
        #     "Ir": ["Ir/It"],
        #     "If": [f"({fluorescence})/I0"],
        #     "trans": ["log(I0/It)", "log(It/Ir)", "I0", "It/I0", "Ir/It"],
        #     "fluorescence": [f"({fluorescence})/I0", "log(I0/It)", "log(It/Ir)", "I0", "It/I0", "Ir/It"],
        #     "ref": ["log(It/Ir)", "It/I0", "Ir/It"],
        # }
        # y_axes = y_lookup[subtype]

        x_axis = "index_count"
        y_axes = [monitored_line]

        for y_axis in y_axes:
            title = " ".join(plan_name)
            subtitle = y_axis
            key = f"{title}: {subtitle}"

            append_figure = False
            if key in self._models:
                print(f"Existing figure")
                models = self._models[key]
                figure = self._figure_dict.get(key, None)
                if not figure or figure not in self.figures:
                    figure = Figure((Axes(),), title=key)
                    self._figure_dict[key] = figure
                    append_figure = True
            else:
                print(f"New figure")
                # model, figure = self.single_plot(f"{title}: {subtitle}", x_axis, y_axis)
                # model, figure = self.single_image(f"{title}: {subtitle}", field=y_axis)
                model, figure = self.single_rastered_image(f"{title}: {subtitle}", field=y_axis, shape=[nx, ny])
                models = [model]
                self._models[key] = [model]
                self._figure_dict[key] = figure
                append_figure = True

            for model in models:
                model.add_run(run)
                self.plot_builders.append(model)
                if append_figure:
                    self.figures.append(figure)

        return model, figure

    def calc_x(self, run):  ##
        print(f"'calc_x' called ...")
        print(f"run={list(run.documents(fill='no'))}")
        return [0, 0.5]

    def calc_y(self, run):  ##
        print(f"'calc_y' called ...")
        return [[1], [2]]

    def single_plot(self, title, x, y):
        axes1 = Axes()
        figure = Figure((axes1,), title=title)
        # x, y = self.calc_x, self.calc_y  ##
        model = Lines(
            x=x,
            ys=[y],
            max_runs=10,
            axes=axes1,
            needs_streams=[monitored_stream_name],
        )
        return model, figure

    def calc_field(self, run):  ##
        print(f"'calc_field' called ...")
        # print(f"start={run._document_cache.start_doc}")
        nx, ny = run._document_cache.start_doc["scan"]["shape"]
        data = run[monitored_stream_name].to_dask().load()
        # print(f"data[monitored_line]={data[monitored_line]}")
        # print(f"data[index_count]={data['index_count']}")
        # print(f"data[reset_count]={data['reset_count']}")
        img_data = data[monitored_line]
        n_total = nx * ny
        if len(img_data) > n_total:
            img_data = img_data[:n_total]
        else:
            img_data = np.pad(img_data, (0, n_total - len(img_data)), constant_values=np.nan)
        img_data = img_data.reshape([ny, nx])
        return img_data

    def single_image(self, title, field):
        axes1 = Axes()
        figure = Figure((axes1,), title=title)
        field = self.calc_field  ##
        model = Images(
            field,
            max_runs=1,
            axes=axes1,
            needs_streams=[monitored_stream_name],
        )
        # for artist in model.axes.artists:
        #     if isinstance(artist, Image):
        #         artist.style.update({"clim": (-50, 50)})
        return model, figure

    def single_rastered_image(self, title, field, shape):
        axes1 = Axes()
        figure = Figure((axes1,), title=title)
        # field = self.calc_field  ##
        model = RasteredImagesSRX(
            field, max_runs=1, axes=axes1, needs_streams=[monitored_stream_name], shape=shape, y_positive="down"
        )
        return model, figure
